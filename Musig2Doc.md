# **Overview**

This is an API document using Musig2. These help use GO to build a threshold signature wallet. In order to cope with the Taproot upgrade, this API also provides the construction of Taproot ordinary transactions and threshold wallet transactions.

# **Api**

## **Construct Transaction**

The following is a function related to constructing transactions

---

### GenerateRawTx(prev_txs, txids, input_indexs, addresses, amounts)

#### illustrate

Build a original transaction for the following calculation trading hash and then sign. Input transaction original text, transaction ID and input transaction index must correspond one by one. The address of the output must be corresponding to the number of output. Support **OP_RETURN**, just set the amout to 0, and the corresponding Address settings need to be attached.

#### **Params and Return**

| **Name**         | **Type** | **Description**     |
| ---------------- | -------- | ------------------- |
| **prev_txs**     | []string | unspent raw tx      |
| **txids**        | []string | unspent txid        |
| **input_indexs** | []uint32 | input indexs list   |
| **addresses**    | []string | output address list |
| **amounts**      | []uint64 | output value        |
| **Return**       | string   | base raw tx         |

#### Return errors

- `txids and indexs must be equal in length`
- `addresses and amounts must be equal in length`
- `Input count must be greater than 0`
- `Output count must be greater than 0`
- `Invalid Transaction`
- `Invalid Tx Input`
- `Invalid Tx Output`

---

### GetSighash(tx, txid, input_index, agg_pubkey, sigversion)

#### **illustrate**

Calculate the transaction hash (sighash). A transaction has multiple inputs, each input needs to calculate a sighash, and then the sighash is signed to get the signature.

#### **Params and Return**

| **Name**        | **Type** | **Description**                                              |
| --------------- | -------- | ------------------------------------------------------------ |
| **tx**          | string   | The results returned by GenerateRawTx                        |
| **txid**        | string   | The transaction id entered                                   |
| **input_index** | uint32   | Input transaction index                                      |
| **agg_pubkey**  | string   | Enter "" for non-threshold addresses; enter the aggregated public key (getAggPublicKey) for threshold addresses |
| **sigversion**  | uint32   | Enter 0 for a non-threshold address and 1 for a threshold address. |
| **Return**      | string   | The currently entered transaction hash                       |

#### **Return errors**

- `Compute Sighash Fail`

---

### GenerateSchnorrSignature(message, privkey)

#### **illustrate**

For non-threshold addresses, use the above sighash and this function to calculate the signature

#### **Params and Return**

| **Name**    | **Type** | **Description**                                             |
| ----------- | -------- | ----------------------------------------------------------- |
| **message** | string   | The message to be signed, i.e. the sighash calculated above |
| **privkey** | string   | The signer's private key                                    |
| **Return**  | string   | Schnorr signature                                           |

#### **Return errors**

- `Invalid Signature`

---

### GetUnsignedTx(tx)

#### **illustrate**

The original unsigned transaction generated from `GenerateRawTx` carries custom additional information and is not a valid original transaction. The purpose of `GetUnsignedTx` is to generate a valid unsigned original transaction that can be parsed by the BTC network.

#### **Params and Return**

| **Name**   | **Type** | **Description**                                           |
| ---------- | -------- | --------------------------------------------------------- |
| **tx**     | string   | Original unsigned transaction with additional information |
| **Return** | string   | Generate a valid unsigned original transaction            |

#### **Return errors**

- `Invalid Transaction`

---


### BuildTaprootTx(tx, signature, input_index)

#### **illustrate**

For non-threshold addresses, use this function to assemble the signature generated by `GenerateSchnorrSignature` into the original transaction generated by `GenerateRawTx`. Each input is signed once, so multiple inputs are assembled multiple times.

#### **Params and Return**

| **Name**        | **Type** | **Description**                                   |
| --------------- | -------- | ------------------------------------------------- |
| **tx**          | string   | `GenerateRawTx` computes the original transaction |
| **signature**   | string   | Single Schnorr Signature                          |
| **input_index** | uint32   | Input transaction index                           |
| **Return**      | string   | Return to the assembled transaction               |

#### **Return errors**

- *`Construct Tx Fail`*

---

### BuildThresholdTx(tx, agg_signature, agg_pubkey, control, input_index)

#### **illustrate**

The function is used to assemble the aggregated signature generated by `Musig2` into the original transaction generated by `GenerateRawTx` when the threshold address is used. Each input is signed once, so multiple inputs are assembled multiple times.

#### **Params and Return**

| **Name**          | **Type** | **Description**                                 |
| ----------------- | -------- | ----------------------------------------------- |
| **tx**            | string   | GenerateRawTx computes the original transaction |
| **agg_signature** | string   | Musig2 Aggregate Signature                      |
| **agg_pubkey**    | string   | Musig2 aggregated public key                    |
| **control**       | string   | Mast generated proof                            |
| **input_index**   | uint32   | Input transaction index                         |
| **Return**        | string   | Return to the assembled transaction             |

#### **Return errors**

- *`Construct Tx Fail`*

---

### GetScriptPubkey(addr)

#### **illustrate**

Generate scirpt_pubkey with addresses, support all address formats.

#### **Params and Return**

| **Name**   | **Type** | **Description** |
| ---------- | -------- | --------------- |
| **addr**   | string   | address         |
| **Return** | string   | scirpt pubkey   |

#### **Return errors**

- `Invalid Address`

---

### GenerateSpentOutputs(prev_txs, input_indexs)

#### **illustrate**

生成spend outputs。使用在Chainx的`createTaprootWithdrawTx`.

#### **Params and Return**

| **Name**         | **Type** | **Description**                       |
| ---------------- | -------- | ------------------------------------- |
| **prev_txs**     | []string | Input transaction array               |
| **input_indexs** | []uint32 | Enter an array of transaction indexes |
| **Return**       | string   | Serialized spend outputs              |

#### **Return errors**

- *`Invalid Spent Outputs`*

---

### GetMyAddress(pubkey, network)

#### **illustrate**

Generate address

#### **Params and Return**

| **Name**    | **Type** | **Description**                                              |
| ----------- | -------- | ------------------------------------------------------------ |
| **pubkey**  | string   | public key                                                   |
| **network** | string   | bitcoin network type，support [“mainnet”，“signet”， “testnet”， “regtest”] |
| **Return**  | string   | address                                                      |

#### **Return errors**

- `Invalid Public Bytes`

---

## **Musig2**

Here are the functions related to aggregated signatures and aggregated public keys

### GetMyPrivkey(phrase, pd_passphrase)

#### **illustrate**

Generate private key by mnemonic and password

#### **Params and Return**

| **Name**          | **Type** | **Description** |
| ----------------- | -------- | --------------- |
| **phrase**        | string   | mnemonic word   |
| **pd_passphrase** | string   | derive password |
| **Return**        | string   | private key     |

#### **Return errors**

- `Construct Secret Key`

---

### GetMyPubkey(private)

#### **illustrate**

Generating public keys from private keys

#### **Params and Return**

| **Name**    | **Type** | **Description** |
| ----------- | -------- | --------------- |
| **private** | string   | private key     |
| **Return**  | string   | public key      |

#### **Return errors**

- *`Null KeyPair Pointer`*
- *`Normal Error`*

---

### GetRound1State()

#### **illustrate**

Musig2 generates the first round of states.

#### **Params and Return**

| **Name**   | **Type** | **Description**      |
| ---------- | -------- | -------------------- |
| **Return** | *C.State | first round of state |

#### **Return errors**

- `null pointer`

---

### GetRound1Msg(state)

#### **illustrate**

Generate messages through the first round of status for delivery to other participants

#### **Params and Return**

| **Name**   | **Type** | **Description**      |
| ---------- | -------- | -------------------- |
| **state**  | *C.State | first round of state |
| **Return** | string   | first round of msg   |

#### **Return errors**

- `Null Round1 State Pointer`
- *`Normal Error`*

---

### EncodeRound1State(state)

#### **illustrate**

Serialization of the first round of states

#### **Params and Return**

| **Name**   | **Type** | **Description**       |
| ---------- | -------- | --------------------- |
| **state**  | *C.State | first round of state  |
| **Return** | string   | Serialization results |

#### **Return errors**

- `Null Round1 State Pointer`
- `Encode Fail`

---

### DecodeRound1State(round1_state)

#### **illustrate**

Deserialization of the first round of state

#### **Params and Return**

| **Name**         | **Type** | **Description**                   |
| ---------------- | -------- | --------------------------------- |
| **round1_state** | string   | Output value of EncodeRound1State |
| **Return**       | *C.State | First round state                 |

#### **Return errors**

- `null pointer`

---

### GetRound2Msg(state, msg, priv, pubkeys, received_round1_msg)

#### **illustrate**

Generate a second round of messages

#### **Params and Return**

| **Name**                | **Type** | **Description**                                              |
| ----------------------- | -------- | ------------------------------------------------------------ |
| **state**               | *C.State | Output value of DecodeRound1State                            |
| **msg**                 | string   | The message to be signed, usually the return value of GetSighash |
| **priv**                | string   | Current participant private key                              |
| **pubkeys**             | []string | All multi-signatory participant public keys                  |
| **received_round1_msg** | []string | First round of messages received from other multi-signature participants |
| **Return**              | string   | Second round of news                                         |

#### **Return errors**

- `null pointer`

---

### GetAggSignature(round2_msg)

#### **illustrate**

Returns the result of aggregated signatures

#### **Params and Return**

| **Name**       | **Type** | **Description**                               |
| -------------- | -------- | --------------------------------------------- |
| **round2_msg** | string   | Second round of messages for all participants |
| **Return**     | string   | Signature Results                             |

#### **Return errors**

- `Normal Error`
- `Null Round2 State Pointer`

---

### GetAggPublicKey(pubkeys)

#### **illustrate**

Generate aggregated public keys

#### **Params and Return**

| **Name**    | **Type** | **Description**                      |
| ----------- | -------- | ------------------------------------ |
| **pubkeys** | string[] | List of public keys to be aggregated |
| **Return**  | string   | Aggregate public keys                |

#### **Return errors**

- `Normal Error`

---

## **Mast**

The following functions are related to generating threshold addresses and proof

### GenerateThresholdPubkey(pubkeys, threshold)

#### **illustrate**

Generate threshold public key

#### **Params and Return**

| **Name**      | **Type** | **Description**         |
| ------------- | -------- | ----------------------- |
| **pubkeys**   | []string | List of all public keys |
| **threshold** | uint8    | Threshold               |
| **Return**    | string   | Aggregate public keys   |

#### **Return errors**

- `Invalid Public Bytes`

---

### GenerateControlBlock(pubkeys, threshold, aggPubkey)

#### **illustrate**

Generate proof

#### **Params and Return**

| **Name**      | **Type** | **Description**                                              |
| ------------- | -------- | ------------------------------------------------------------ |
| **pubkeys**   | []string | List of all public keys                                      |
| **threshold** | uint8    | Threshold                                                    |
| **aggPubkey** | string   | The aggregated public key of this multi-signature participant |
| **Return**    | string   | proof                                                        |

#### **Return errors**

- `Invalid Public Bytes`

---

# **Example**

The following examples are provided: constructing a non-gated address, spending a non-gated address, constructing a gated signature address, and spending a gated signature address. The full code can be viewed in [demo](. /demo/musig2demo.go).

## **Details**

### Generate non-threshold signature addresses

1. Generate private key by passing in mnemonic and password

   ~~~go
   private0, err := musig2.GetMyPrivkey(PHRASE0, "")
   ~~~

2. Generate public key

   ~~~go
   pubkey0, err := musig2.GetMyPubkey(private0)
   ~~~

3. Generate address

   ~~~go
   address0, err := musig2.GetMyAddress(pubkey0, "signet")
   ~~~

### Spending on non-threshold signature addresses

1. **Create an unsigned transaction by `generateRawTx`**. txids and indexes are used to construct all inputs to the transaction, and a txid and an index are used to locate the only unspent output. The following **prev_txs, txids and input_indexes are the same length and correspond to each other**. addddress and amounts are used to construct all the outputs of a transaction, and an addddress and an amount indicate how many coins are sent to an address. **adddress has no order requirement, just amounts one by one**. With here `1f8e0f7dfa37b184244d022cdf2bc7b8e0bac8b52143ea786fa3f7bbe049eeae` and `1` uniquely identifies an unspent output, and the address to which this unspent output belongs is a **non-threshold address**. The corresponding rev_tx can be looked up using the txid. `35516a706f3772516e7751657479736167477a6334526a376f737758534c6d4d7141754332416255364c46464646476a38` represents the `op_ return`, which corresponds to an amout of 0. `tb1pn202yeugfa25nssxk2hv902kmxrnp7g9xt487u256n20jgahuwasdcjfdw` is the recipient's address, and `100000` is the transfer amount. `tb1pexff2s7l58sthpyfrtx500ax234stcnt0gz2lr4kwe0ue95a2e0srxsc68` is the change address and `400000` is the change amount. Calculation method refer to **Commission and change balance calculation**.

2. ~~~go
   prev_txs :=[]string{"020000000001014be640313b023c3c731b7e89c3f97bebcebf9772ea2f7747e5604f4483a447b601000000000000000002a0860100000000002251209a9ea267884f5549c206b2aec2bd56d98730f90532ea7f7154d4d4f923b7e3bbc027090000000000225120c9929543dfa1e0bb84891acd47bfa6546b05e26b7a04af8eb6765fcc969d565f01404dc68b31efc1468f84db7e9716a84c19bbc53c2d252fd1d72fa6469e860a74486b0990332b69718dbcb5acad9d48634d23ee9c215ab15fb16f4732bed1770fdf00000000"}
   txids := []string{"1f8e0f7dfa37b184244d022cdf2bc7b8e0bac8b52143ea786fa3f7bbe049eeae"}
   input_indexs := []uint32{1}
   addresses := []string{"tb1pn202yeugfa25nssxk2hv902kmxrnp7g9xt487u256n20jgahuwasdcjfdw", "35516a706f3772516e7751657479736167477a6334526a376f737758534c6d4d7141754332416255364c464646476a38", "tb1pexff2s7l58sthpyfrtx500ax234stcnt0gz2lr4kwe0ue95a2e0srxsc68"}
   amounts = []uint64{100000, 0, 400000}
   base_tx, err := musig2.GenerateRawTx(prev_txs, txids, input_indexs, addresses, amounts)
   ~~~

3. **Signing the output to be spent**. To sign the UTXO to be spent first calculate the sighash of this unspent output, the signature is to sign the sighash.

   txid and input_index are used to locate the output to be spent, agg_pubkey fills in the empty string `""` for non-gated signature addresses, sigversion fills in 0 for non-gated signature addresses, and tx is the currently constructed transaction. **Note that when calculating sighash, the result constructed with the above `generateRawTx` must always be unchangeable. **

   ~~~go
   sighash, err := musig2.GetSighash(baseTx, txids[i], inputIndexs[i], "", 0)
   ~~~

   After calculating the sighash, the private key is used to sign it. message is the sighash and privkey is the private key.

   ~~~go
   schnorrSignature, err := musig2.GenerateSchnorrSignature(sighash, privkey)
   ~~~

4. **Assemble the above signatures into transactions**. tx is the current transaction to be constructed, txid and input_index are still used to locate the input corresponding to the signature in tx.

   ~~~go
   taprootTx, err = musig2.BuildTaprootTx(baseTx, schnorrSignature, txids[i], inputIndexs[i])
   ~~~

   **Note that if there are multiple inputs in tx, then Step2 and Step3 need to be repeated for each output to be signed and added to tx, as shown in the for loop below:. **

   ![](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Document/16523346050391652334604157.png)

### Generate threshold signature address

1. A 2-of-3 threshold signature address is generated as follows. The threshold public key is generated by first passing in the public keys of all participants and the threshold value.

   ~~~go
   thresholdPubkey, err := musig2.GenerateThresholdPubkey([]string{pubkey0, pubkey1, pubkey2}, 2)
   ~~~

2. Then encode the public key into an address, you can get the threshold address

   ~~~go
   thresholdAddress, err := musig2.GetMyAddress(thresholdPubkey, "signet")
   ~~~

### Threshold signature address spend

1. **Create an unsigned transaction by `generateRawTx`**. txids and indexes are used to construct all inputs to the transaction, and a txid and an index are used to locate the only unspent output. The following **prev_txs, txids and input_indexes are the same length and correspond to each other**. addddress and amounts are used to construct all the outputs of a transaction, and an addddress and an amount indicate how many coins are sent to an address. **adddress has no order requirement, only amounts correspond to each other**. Here `8e5d37c768acc4f3e794a10ad27bf0256237c80c22fa67117e3e3e1aec22ea5f` and `0` uniquely identify an unspent output, note that the address to which this unspent output belongs is a **threshold address**. The corresponding rev_tx can be queried using the txid.

   `tb1pexff2s7l58sthpyfrtx500ax234stcnt0gz2lr4kwe0ue95a2e0srxsc68` is the recipient's address and `50000` is the transfer amount. `tb1pn202yeugfa25nssxk2hv902kmxrnp7g9xt487u256n20jgahuwasdcjfdw` is the change address and `40,000` is the change amount. Of course you can also bring `op_return` here. Calculation method reference **Fee and change balance calculation**
   
2. ~~~go
   prev_txs = []string{"02000000000101aeee49e0bbf7a36f78ea4321b5c8bae0b8c72bdf2c024d2484b137fa7d0f8e1f01000000000000000003a0860100000000002251209a9ea267884f5549c206b2aec2bd56d98730f90532ea7f7154d4d4f923b7e3bb0000000000000000326a3035516a706f3772516e7751657479736167477a6334526a376f737758534c6d4d7141754332416255364c464646476a38801a060000000000225120c9929543dfa1e0bb84891acd47bfa6546b05e26b7a04af8eb6765fcc969d565f01409e325889515ed47099fdd7098e6fafdc880b21456d3f368457de923f4229286e34cef68816348a0581ae5885ede248a35ac4b09da61a7b9b90f34c200872d2e300000000"};
   txids = []string{"8e5d37c768acc4f3e794a10ad27bf0256237c80c22fa67117e3e3e1aec22ea5f"};
   input_indexs = []uint32{0};
   addresses = []string{"tb1pexff2s7l58sthpyfrtx500ax234stcnt0gz2lr4kwe0ue95a2e0srxsc68","tb1pn202yeugfa25nssxk2hv902kmxrnp7g9xt487u256n20jgahuwasdcjfdw"};
   amounts = []uint64{50000, 40000};
   string base_tx = musig2.GenerateRawTx(prev_txs, txids, input_indexs, addresses, amounts);
   ~~~

3. **Signing the output to be spent**. Signing the UTXO to be spent first calculates the sighash of this unspent output, and signing is the signing of the sighash.

   txid and input_index are used to locate that output to be spent. agg_pubkey fills in the empty string aggregated public key for the threshold signature address, as follows: B and C are the two people who perform the aggregated signature spending, then fill in the aggregated public key of B and C. sigversion fills in 1 for the threshold signature address, and tx is the currently constructed transaction.

   **Compute sighash**

   ~~~go
   pubkeyBC, err := musig2.GetAggPublicKey([]string{pubkeyB, pubkeyC})
   sighash, err := musig2.GetSighash(baseTx, txids[i], inputIndexs[i], pubkeyBC, 1)
   ~~~

   **Compute the signature**: After computing the sighash, B and C both use Musig2 to aggregate the signatures. The signed message is the sighash.

   ~~~go
   round1State0 := musig2.GetRound1State()
   round1State0Encode, err := musig2.EncodeRound1State(round1State0)
   round1State0 = musig2.DecodeRound1State(round1State0Encode)
   round1State1 := musig2.GetRound1State()
   
   round1Msg0, err := musig2.GetRound1Msg(round1State0)
   round1Msg1, err := musig2.GetRound1Msg(round1State1)
   round2Msg0, err := musig2.GetRound2Msg(round1State0, sighash, privateB, []string{pubkeyB, pubkeyC}, []string{round1Msg1})
   round2Msg1, err := musig2.GetRound2Msg(round1State1, sighash, privateC, []string{pubkeyB, pubkeyC}, []string{round1Msg0})
   multiSignature, err := musig2.GetAggSignature([]string{round2Msg0, round2Msg1})
   controlBlock, err := musig2.GenerateControlBlock([]string{pubkeyA, pubkeyB, pubkeyC}, 2, pubkeyBC)
   ~~~

   The following is a detailed description of the Musig2 multi-signature process described above, divided into the following steps.

   1. Generate the state of the first round

      ~~~go
      round1State0 := musig2.GetRound1State()
      ~~~

   2. The first round message is obtained from the first round state and passed to the other signature participants.

      ~~~go
      round1Msg0, err := musig2.GetRound1Msg(round1State0)
      ~~~

   3. Takes the first round of messages from other signature participants, generates the second round of messages, and passes them to other participants. `received_round1_msg` is the first round of messages received from other participants. `pubkeys` is the public key of all participants. `msg` is the message to be signed. `state` is the state of the first round. `priv` is the private key of the signer.

      ~~~go
      round2Msg0, err := musig2.GetRound2Msg(round1State0, sighash, privateB, []string{pubkeyB, pubkeyC}, []string{round1Msg1})
      ~~~

   4. Generate aggregated signatures using the second round of messages from all participants. `round2_msg` is the second round of messages for all participants.

      ~~~go
      string multi_signature = getAggSignature(new []string{round2_msg0, round2_msg1})
      ~~~

   **Compute proof**: The threshold signature costs not only the signature but also the proof, which requires passing in the public keys of everyone, the threshold and the aggregated public keys of participants B and C of this signature.

   ~~~java
   controlBlock, err := musig2.GenerateControlBlock([]string{pubkeyA, pubkeyB, pubkeyC}, 2, pubkeyBC)
   ~~~

4. **Assemble the above signatures and proofs for the transaction**. tx is the current transaction to be constructed, agg_signature is the aggregated signature of B and C, agg_pubkey is the aggregated public key of B and C, txid and input_index are still used to locate the input corresponding to the signature in tx, and txid and input_index correspond to of the unspent output corresponds to the second step.

   ~~~go
   thresholdTx, err = musig2.BuildThresholdTx(baseTx, multiSignature, pubkeyBC, controlBlock, txids[i], inputIndexs[i])
   ~~~

   **Note that if there are multiple inputs in tx, then Step2 and Step3 need to be repeated for each output to be signed and added to tx, as shown in the for loop below.**

   ![](https://cdn.jsdelivr.net/gh/hacpy/PictureBed@master/Document/16523351090411652335108767.png)

## Handling fee and change balance calculation

Background: A wants to transfer to `B 2BTC`,` C 3BTC`

1. Find all unspent transaction txids and balances by A's address and sort them from largest to smallest, assuming `[(txid1, 4), (txid2, 2), (tixd3, 1), (tixd4, 1)]`.

2. add up the txids and the balance list and find the txid that is greater than the output amount 2+3=5, which is txid2, or return the disallowed transfer if not found.

3. Defer from txid2 backwards one place, using `[(txid1, 4), (txid2, 2), (tixd3, 1)]` as input. If txid2 is the last one, use `[(txid1, 4), (txid2, 2)]` as input.

4. Estimate the number of transaction bytes using the number of inputs and outputs and the following formula.

   **Estimate of the number of bytes spent on non-threshold addresses**

   ~~~
   105 + 58 * input_count(threshold_address) + 43 * output_count
   ~~~
   `input_count(taproot_address)` indicates the number of input txid when the non-threshold address is spent

   Estimated number of bytes for the threshold address

   ```
   105 + 141 * input_count(threshold_address) + 43 * output_count
   ```
   `input_count(threshold_address)` indicates the number of input txid when the threshold address is spent

5. Multiply the current `FEE RATES` by the number of bytes to get the transaction fee.

2. Multiply `INPUT TOTAL - (OUTPUT TOTAL + FEE RATES)` to get `CHANGE AMOUNT`. If it is negative, there is no zero (i.e., the output list is not filled with zero addresses and amounts), so the transaction fee becomes `Total Input Amount - Total Output Amount`.

# Other

- Lock script script_pubkey that converts addresses to output in bitcoin transactions

  ~~~go
  scriptPubkey, err := musig2.GetScriptPubkey("tb1pn202yeugfa25nssxk2hv902kmxrnp7g9xt487u256n20jgahuwasdcjfdw")
  ~~~

- Extracts a valid unsigned original transaction from the original unsigned transaction generated by `generateRawTx`.

  ~~~go
  unsignedTx, err := musig2.GetUnsignedTx(baseTx)
  ~~~
